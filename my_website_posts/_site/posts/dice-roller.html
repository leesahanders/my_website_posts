<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Lisa">
<meta name="dcterms.date" content="2025-07-05">

<title>Lisa Anders - questionable.quarto - Using LLM’s to make a dice roller</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title"><span class="icon-upper">LISA ANDERS</span><span class="icon-sep"></span><span class="icon-lower">questionable.quarto</span></span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-stuff" role="button" data-bs-toggle="dropdown" aria-expanded="false">
      <i class="bi bi-fa-database" role="img">
</i> 
 <span class="menu-text">Stuff</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-stuff">    
        <li>
    <a class="dropdown-item" href="../index.html">
 <span class="dropdown-text">Blog / Projects</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://questionable.quarto.pub/blog/lists.html">
 <span class="dropdown-text">Lists</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://questionable.quarto.pub/blog/presentations.html">
 <span class="dropdown-text">Presentations</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://questionable.quarto.pub/recipes/">
 <span class="dropdown-text">Recipes</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://questionable.quarto.pub/blog/work.html">
 <span class="dropdown-text">Technical writeups</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Blog / Projects</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://questionable.quarto.pub/blog/about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://questionable.quarto.pub/blog/site_map.html"> 
<span class="menu-text">Site Map</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/leesahanders/my_website"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Using LLM’s to make a dice roller</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">code</div>
                <div class="quarto-category">dice</div>
                <div class="quarto-category">games</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Lisa </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">July 5, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="the-dice-roller" class="level2">
<h2 class="anchored" data-anchor-id="the-dice-roller">The Dice Roller</h2>
&lt;!DOCTYPE html&gt;


<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
Universal Dice Roller
</title>
<!-- Tailwind CSS CDN -->
<script src="https://cdn.tailwindcss.com"></script>
<!-- Google Fonts - Inter -->
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&amp;display=swap" rel="stylesheet">
<style>
        /* Custom CSS for the spinning animation */
        @keyframes spin-fast {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .animate-spin-fast {
            animation: spin-fast 0.3s linear infinite;
        }
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>


<div id="root">

</div>
<!-- React and ReactDOM CDNs -->
<script crossorigin="" src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script crossorigin="" src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<!-- Babel CDN for JSX transformation -->
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script type="text/babel">
        // Main App component for the dice roller application
        const App = () => {
            // Define available dice types and their maximum values
            const diceTypes = [
                { type: 'd4', max: 4 },
                { type: 'd6', max: 6 },
                { type: 'd8', max: 8 },
                { type: 'd12', max: 12 },
                { type: 'd20', max: 20 },
                { type: 'd100', max: 100 },
            ];

            // State for the currently selected dice type (default to d6)
            const [selectedDiceType, setSelectedDiceType] = React.useState(diceTypes[1]); // d6 is at index 1
            // State to store the current value of the dice
            const [diceValue, setDiceValue] = React.useState(1);
            // State to control the rolling animation
            const [isRolling, setIsRolling] = React.useState(false);
            // State to store the LLM-generated dice insight
            const [diceInsight, setDiceInsight] = React.useState('');
            // State to control the loading indicator for the LLM insight
            const [isLoadingInsight, setIsLoadingInsight] = React.useState(false);
            // State to store any error messages from the LLM API call
            const [insightError, setInsightError] = React.useState('');

            /**
             * Renders the face of the dice. Now always shows the number.
             * @param {number} value The current dice value.
             * @param {string} type The type of dice (e.g., 'd6', 'd20').
             * @returns {JSX.Element} The JSX element representing the dice face.
             */
            const renderDiceFace = (value, type) => {
                // For all dice types, display the number directly
                return (
                    <span className="text-5xl md:text-6xl font-bold text-white drop-shadow-md">
                        {value}
                    </span>
                );
            };

            /**
             * Handles the dice rolling logic.
             * Generates a random number based on the selected dice type.
             * Includes a visual rolling animation.
             */
            const rollDice = () => {
                if (isRolling) return; // Prevent multiple rolls while already rolling

                setIsRolling(true); // Start the rolling animation
                setDiceInsight(''); // Clear previous insight
                setInsightError(''); // Clear previous error

                const animationDuration = 1500; // 1.5 seconds for the main animation

                // After the main animation duration, calculate the final value
                setTimeout(() => {
                    const finalValue = Math.floor(Math.random() * selectedDiceType.max) + 1; // Generate random number
                    setDiceValue(finalValue); // Update dice value to the final result

                    // Introduce a tiny additional delay to ensure React has a chance to update the DOM
                    // with the new diceValue BEFORE the 'isRolling' overlay is removed.
                    setTimeout(() => {
                        setIsRolling(false); // End the rolling animation, remove overlay
                    }, 50); // Small additional delay (e.g., 50ms)
                }, animationDuration);
            };

            /**
             * Calls the Gemini API to get an insight based on the dice value and type.
             */
            const getDiceInsight = async () => {
                setIsLoadingInsight(true);
                setInsightError('');
                setDiceInsight(''); // Clear previous insight

                const prompt = `Provide a very short, whimsical, and positive interpretation or fortune for a roll of ${diceValue} on a ${selectedDiceType.type} dice. Make it sound like a fun, lighthearted prediction. Keep it to one sentence.`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; // Canvas will automatically provide the API key at runtime
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
                    }

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const text = result.candidates[0].content.parts[0].text;
                        setDiceInsight(text);
                    } else {
                        setInsightError("Could not get a valid insight from the AI. Please try again.");
                        console.error("Unexpected API response structure:", result);
                    }
                } catch (error) {
                    setInsightError(`Failed to get insight: ${error.message}`);
                    console.error("Error fetching dice insight:", error);
                } finally {
                    setIsLoadingInsight(false);
                }
            };

            // Initial roll when the component mounts or dice type changes
            React.useEffect(() => {
                rollDice();
            }, [selectedDiceType]); // Re-roll when selectedDiceType changes

            return (
                <div className="min-h-screen bg-gradient-to-br from-indigo-800 to-purple-900 flex flex-col items-center justify-center p-4 font-inter text-white">
                    <h1 className="text-4xl md:text-5xl font-bold mb-8 text-center drop-shadow-lg">
                        Universal Dice Roller
                    </h1>

                    {/* Dice Type Selection Buttons */}
                    <div className="flex flex-wrap justify-center gap-2 mb-8 max-w-full">
                        {diceTypes.map((dice) => (
                            <button
                                key={dice.type}
                                onClick={() => setSelectedDiceType(dice)}
                                className={`
                                    px-4 py-2 rounded-full font-semibold text-sm md:text-base
                                    transition-all duration-200 ease-in-out
                                    ${selectedDiceType.type === dice.type
                                        ? 'bg-emerald-500 text-white shadow-md'
                                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600 hover:text-white'
                                    }
                                    focus:outline-none focus:ring-2 focus:ring-emerald-400 focus:ring-opacity-75
                                `}
                                disabled={isRolling || isLoadingInsight}
                            >
                                {dice.type.toUpperCase()}
                            </button>
                        ))}
                    </div>

                    {/* Dice Visualization Component */}
                    <div className={`
                        relative w-40 h-40 md:w-48 md:h-48 bg-red-600 rounded-2xl shadow-2xl flex items-center justify-center
                        transition-transform duration-300 ease-out
                        ${isRolling ? 'animate-spin-fast' : 'transform rotate-0'}
                    `}>
                        {/* Visual dice face is rendered only when not rolling */}
                        {!isRolling && renderDiceFace(diceValue, selectedDiceType.type)}
                        {/* Overlay for rolling effect */}
                        {isRolling && (
                            <div className="absolute inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center rounded-2xl">
                                <span className="text-3xl font-bold text-white animate-pulse">Rolling...</span>
                            </div>
                        )}
                    </div>

                    {/* Result Display Component */}
                    <div className="mt-8 text-6xl md:text-7xl font-extrabold text-white drop-shadow-lg">
                        {diceValue}
                    </div>

                    {/* Roll Button */}
                    <button
                        onClick={rollDice}
                        disabled={isRolling || isLoadingInsight} // Disable button while rolling or getting insight
                        className={`
                            mt-12 px-8 py-4 bg-blue-600 hover:bg-blue-700 text-white font-bold text-xl rounded-full shadow-lg
                            transition-all duration-300 ease-in-out transform
                            ${isRolling || isLoadingInsight ? 'opacity-70 cursor-not-allowed' : 'hover:scale-105 active:scale-95'}
                            focus:outline-none focus:ring-4 focus:ring-blue-500 focus:ring-opacity-50
                            relative overflow-hidden
                        `}
                    >
                        {isRolling ? (
                            <span className="flex items-center">
                                <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                                Rolling...
                            </span>
                        ) : (
                            `Roll ${selectedDiceType.type.toUpperCase()}`
                        )}
                        {/* Button hover effect */}
                        <span className="absolute inset-0 bg-white opacity-0 transition-opacity duration-300 rounded-full group-hover:opacity-10"></span>
                    </button>

                    {/* Gemini API Insight Button */}
                    <button
                        onClick={getDiceInsight}
                        disabled={isRolling || isLoadingInsight} // Disable while rolling or loading insight
                        className={`
                            mt-4 px-8 py-4 bg-purple-600 hover:bg-purple-700 text-white font-bold text-xl rounded-full shadow-lg
                            transition-all duration-300 ease-in-out transform
                            ${isRolling || isLoadingInsight ? 'opacity-70 cursor-not-allowed' : 'hover:scale-105 active:scale-95'}
                            focus:outline-none focus:ring-4 focus:ring-purple-500 focus:ring-opacity-50
                            relative overflow-hidden
                        `}
                    >
                        {isLoadingInsight ? (
                            <span className="flex items-center">
                                <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                                Getting Insight...
                            </span>
                        ) : (
                            '✨ Get Dice Insight ✨'
                        )}
                        <span className="absolute inset-0 bg-white opacity-0 transition-opacity duration-300 rounded-full group-hover:opacity-10"></span>
                    </button>

                    {/* Display Dice Insight or Error */}
                    {(diceInsight || insightError) && (
                        <div className="mt-8 p-6 bg-gray-800 bg-opacity-70 rounded-xl shadow-xl text-center max-w-md mx-auto">
                            {diceInsight && (
                                <p className="text-lg md:text-xl text-yellow-300 font-semibold italic">
                                    "{diceInsight}"
                                </p>
                            )}
                            {insightError && (
                                <p className="text-lg md:text-xl text-red-400 font-semibold">
                                    Error: {insightError}
                                </p>
                            )}
                        </div>
                    )}
                </div>
            );
        };

        // Render the App component into the 'root' div
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>


</section>
<section id="background" class="level2">
<h2 class="anchored" data-anchor-id="background">Background</h2>
<p>I wanted to make a simple dice roller for using when I’m on the road and want to play an RPG with a friend.</p>
<p>Started with this prompt, trying to be detailed and specific: “Reply with the instructions to make a phone application using open source software. The application should be simple and simulate rolling a d6 dice. It should have a UI component that visualizes rolling a dice and a component that displays the final number. Check that the rolls are truly random. Explain the components of the application and how a user can run them. Respond as if you were teaching a university course on app design.”</p>
<p>It told us this about the application:</p>
<blockquote class="blockquote">
<p>Hello class, and welcome to this session on app design! Today, we’re going to tackle a fundamental concept: building a simple, interactive application that simulates a d6 dice roll. This project will introduce you to core principles of front-end development, user interface design, and the importance of randomness in simulations.</p>
</blockquote>
<blockquote class="blockquote">
<p>We’ll be using React, a popular open-source JavaScript library for building user interfaces, along with standard HTML and CSS (specifically, Tailwind CSS for rapid styling). While this will be a web-based application, it’s designed to be fully responsive and can be easily accessed and used on any modern phone browser, giving it the feel of a native app without the complexities of platform-specific development.</p>
</blockquote>
<blockquote class="blockquote">
<p>Our application will have two main components:</p>
</blockquote>
<blockquote class="blockquote">
<p>The Dice Visualization Component: This will be a visual representation of a six-sided die, showing the dots corresponding to the rolled number. We’ll make it animate slightly to simulate the “roll.”</p>
</blockquote>
<blockquote class="blockquote">
<p>The Result Display Component: This will clearly show the numerical outcome of the dice roll.</p>
</blockquote>
<blockquote class="blockquote">
<p>The Roll Button: An interactive element to trigger the dice roll.</p>
</blockquote>
<blockquote class="blockquote">
<p>** Understanding the Application Components**</p>
</blockquote>
<blockquote class="blockquote">
<p>Let’s break down the key parts of this React application:</p>
</blockquote>
<blockquote class="blockquote">
<ol type="1">
<li><strong><code>App</code> Component:</strong></li>
</ol>
</blockquote>
<blockquote class="blockquote">
<pre><code>- This is the root component of our application. It's a functional component, which is the modern way to write React components.</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>- **State Management (`useState`):**</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>    - `diceValue`: This state variable holds the current number displayed on the dice. When `setDiceValue` is called, React re-renders the component to show the new number.</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>    - `isRolling`: This boolean state controls the visual "rolling" effect and disables the button during a roll.</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>- **`renderDiceDots(value)` Function:** This helper function is responsible for the visual representation of the dice. It takes the `diceValue` and returns an array of `div` elements, each representing a dot on the dice face. The positioning of these dots is precisely calculated using Tailwind's fractional positioning classes (`top-1/4`, `left-1/2`, etc.) and CSS `transform` for centering. This makes the dice look like an actual die face.</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>- **`rollDice()` Function:**</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>    - This is the core logic for our dice roll.</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>    - **Randomness:** `Math.random()` is used to generate a pseudo-random floating-point number between 0 (inclusive) and 1 (exclusive). We then multiply it by 6, use `Math.floor()` to get an integer between 0 and 5, and add 1 to get a number between 1 and 6. This is a standard and robust way to simulate dice rolls in JavaScript.</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>    - **Simulation of Rolling:** To make the roll feel more dynamic, we use `setInterval` to rapidly change the `diceValue` a few times, giving the impression of the dice tumbling. After a short period, `setTimeout` is used to set the final, truly random value and end the `isRolling` state.</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>    - **Preventing Multiple Rolls:** The `if (isRolling) return;` line ensures that a user cannot spam the roll button while a roll is already in progress, preventing unexpected behavior.</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>- **`useEffect` Hook:** This hook is used to perform side effects in functional components. Here, `useEffect(() =&gt; { rollDice(); }, []);` ensures that a dice roll happens automatically when the application first loads, providing an initial state. The empty dependency array `[]` means this effect only runs once after the initial render.</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>- **JSX (UI Structure):** The `return` statement contains the JSX (JavaScript XML) that defines the structure and appearance of our application.</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>    - **Main Container:** A `div` with `min-h-screen`, `flex` properties, and a gradient background from Tailwind CSS ensures the app fills the screen and centers its content.</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>    - **Dice Display:** A `div` styled as a red square with rounded corners and a shadow represents the dice. It uses `relative` positioning so the dots can be absolutely positioned within it. The `isRolling` state dynamically adds an `animate-spin-fast` class for the visual roll effect and an overlay to show "Rolling...".</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>    - **Result Display:** A large, bold `div` displays the numerical `diceValue`.</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>    - **Roll Button:** A styled button triggers the `rollDice` function. It's disabled when `isRolling` is true and includes a simple loading spinner for better user feedback.</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>- **Tailwind CSS:** We load Tailwind CSS via its CDN. This allows us to use utility classes directly in our JSX to style elements, making the app responsive and visually appealing without writing custom CSS files.</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>- **Custom CSS:** A small `&lt;style&gt;` block is included for the `animate-spin-fast` keyframe animation, as this is a custom animation not directly provided by Tailwind's default classes.</code></pre>
</blockquote>
<blockquote class="blockquote">
<p><strong>Ensuring Randomness</strong></p>
</blockquote>
<blockquote class="blockquote">
<p>The core of our randomness comes from <code>Math.random()</code>. This function generates what is known as <strong>pseudo-random numbers</strong>. This means the numbers are generated by a deterministic algorithm, but they appear random enough for most practical purposes, including this dice rolling simulation. For cryptographic security or highly sensitive scientific simulations, more robust random number generators (RNGs) might be needed, but for an everyday dice app, <code>Math.random()</code> is perfectly adequate and widely accepted. Each roll is independent of the previous one, and over many rolls, you would expect an even distribution of numbers from 1 to 6.</p>
</blockquote>
<blockquote class="blockquote">
<p><strong>How to Run the Application</strong></p>
</blockquote>
<blockquote class="blockquote">
<p>Since this is a web-based React application bundled into a single HTML file, running it is straightforward:</p>
</blockquote>
<blockquote class="blockquote">
<ol type="1">
<li><strong>Save the Code:</strong> Copy the entire code block provided above and save it as an HTML file (e.g., <code>dice_roller.html</code>). Make sure to include the <code>&lt;!DOCTYPE html&gt;</code> and <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, <code>&lt;body&gt;</code> tags around the React app for it to be a complete HTML document.</li>
</ol>
</blockquote>
<blockquote class="blockquote">
<ol start="2" type="1">
<li><strong>Open in Browser:</strong></li>
</ol>
</blockquote>
<blockquote class="blockquote">
<pre><code>- **On Desktop:** Simply double-click the `dice_roller.html` file. It will open in your default web browser.</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>- **On Phone:**</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>    - **Method A (Local Server - Recommended for testing):** If you have Python installed, navigate to the directory where you saved `dice_roller.html` in your terminal and run `python -m http.server`. This will start a local web server (usually on `http://localhost:8000`). You can then access this URL from your phone's browser if both devices are on the same Wi-Fi network (you might need to use your computer's local IP address instead of `localhost`).</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>    - **Method B (Cloud Hosting):** For easier access, you could upload this `dice_roller.html` file to a simple web hosting service (like GitHub Pages, Netlify, Vercel, or even a free static site host). Once hosted, you'll get a URL that you can simply open in your phone's browser.</code></pre>
</blockquote>
<blockquote class="blockquote">
<pre><code>    - **Method C (Direct File Transfer - Less common for web apps):** You could transfer the HTML file directly to your phone's storage and open it with a file browser that supports opening HTML files in a web view. However, this method might have limitations with external CDN scripts.</code></pre>
</blockquote>
<blockquote class="blockquote">
<p>This approach allows you to create a functional and visually appealing application that runs across various devices using widely adopted open-source technologies. It’s a great starting point for understanding how modern web applications are built!</p>
</blockquote>
<blockquote class="blockquote">
<p>In the future consider Progressive Web App (PWA): Learn how to turn this web application into a PWA, allowing users to “install” it to their home screen and even use it offline.</p>
</blockquote>
<p>We then had it expand into multiple dice and fixed the issue with the dots not matching the number by having it only show the number: “Now add the ability to switch between dice typea: d4, d6, d8, D12, d20, and d100. The number rolled and the number on the dice don’t match. They should match. Please make it so that all dice roll numbers, not dots. Add a readme that provides: instructions for how to run it, troubleshooting tips, overall architecture, and recommended next steps.”</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>